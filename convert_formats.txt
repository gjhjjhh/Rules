#!/usr/bin/env python3
"""
ç”Ÿæˆæ–‡ä»¶è·¯å¾„ï¼šä¸»ç›®å½•/output/[è§„åˆ™åç§°]/[æ ¼å¼æ–‡ä»¶]
å–æ¶ˆå†—ä½™æ–‡ä»¶ç”Ÿæˆï¼Œä»…ä¿ç•™å¿…è¦æ ¼å¼
"""
import os
import json
import subprocess
from datetime import datetime
from pathlib import Path

# æ ¸å¿ƒé…ç½®ï¼šè¾“å‡ºç›®å½•è°ƒæ•´ä¸º ä¸»ç›®å½•/output/è§„åˆ™åç§°/
BASE_DIR = Path(__file__).parent  # è„šæœ¬æ‰€åœ¨ç›®å½•ï¼ˆä¸»ç›®å½•ï¼‰
DOMAIN_DIR = BASE_DIR / "domain"  # è¾“å…¥ï¼šdomainç›®å½•ï¼ˆä¸»ç›®å½•ä¸‹ï¼‰
OUTPUT_ROOT = BASE_DIR / "output"  # è¾“å‡ºæ ¹ç›®å½•ï¼šä¸»ç›®å½•/output/
REPO_URL = "https://github.com/your-repo"  # æ›¿æ¢ä¸ºå®é™…ä»“åº“åœ°å€
SOURCE_RULE = "åŸŸåè§„åˆ™é›†åˆ"

# ä¿ç•™å¿…è¦æ ¼å¼ï¼ˆå–æ¶ˆå†—ä½™æ ¼å¼ï¼ŒæŒ‰éœ€ä¿ç•™ï¼‰
FORMAT_CONFIG = {
    "singbox": {
        "suffix": ".json",
        "comment": "//",
        "title": "Singboxè§„åˆ™é›†",
        "desc": "é€‚ç”¨äºSingboxçš„åŸŸåæ‹¦æˆªè§„åˆ™",
        "convert": lambda domains: {
            "version": 3,
            "rules": [{"domain_suffix": [d for d in domains if d.strip()]}]
        }
    },
    "adblock": {
        "suffix": ".txt",
        "comment": "!",
        "title": "Adblockè§„åˆ™",
        "desc": "é€‚ç”¨äºAdblockåè®®çš„æ‹¦æˆªè§„åˆ™",
        "convert": lambda domains: [f"||{d}^" for d in domains if d.strip()]
    },
    "mihomo": {
        "suffix": ".yaml",
        "comment": "#",
        "title": "Mihomoè§„åˆ™é›†",
        "desc": "é€‚ç”¨äºClash Meta(Mihomo)çš„è§„åˆ™",
        "convert": lambda domains: ["payload:"] + [f"  - '+.{d}'" for d in domains if d.strip()]
    },
    "hosts": {
        "suffix": ".txt",
        "comment": "#",
        "title": "Hostsè§„åˆ™",
        "desc": "é€‚ç”¨äºç³»ç»ŸHostsçš„æ‹¦æˆªè§„åˆ™",
        "convert": lambda domains: ["127.0.0.1\tlocalhost", "0.0.0.0\t0.0.0.0", ""] + [f"0.0.0.0\t{d}" for d in domains if d.strip()]
    }
}

# ç¡®ä¿è¾“å‡ºæ ¹ç›®å½•å­˜åœ¨
OUTPUT_ROOT.mkdir(exist_ok=True)


def get_meta():
    """è·å–å…ƒæ•°æ®ï¼ˆç‰ˆæœ¬ã€æ—¶é—´ç­‰ï¼‰"""
    try:
        version = subprocess.check_output(
            ['git', 'describe', '--abbrev=0', '--tags'],
            stderr=subprocess.STDOUT,
            cwd=BASE_DIR
        ).strip().decode() or "unknown"
    except:
        version = "unknown"
    return {
        "version": version,
        "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S") + " UTC+8",
        "repo": REPO_URL
    }


def read_domains(file_path: Path) -> list:
    """è¯»å–åŸŸåæ–‡ä»¶ï¼ˆå»é‡+è¿‡æ»¤ç©ºè¡Œï¼‰"""
    with open(file_path, 'r', encoding='utf-8') as f:
        return list(set([line.strip() for line in f if line.strip()]))


def process_file(file_path: Path, meta: dict):
    """å¤„ç†å•ä¸ªåŸŸåæ–‡ä»¶ï¼Œç”Ÿæˆåˆ° output/è§„åˆ™åç§°/ ç›®å½•"""
    domains = read_domains(file_path)
    if not domains:
        print(f"âš ï¸ è·³è¿‡ç©ºæ–‡ä»¶: {file_path.name}")
        return

    # è§„åˆ™åç§° = åŸŸåæ–‡ä»¶åï¼ˆä¸å«åç¼€ï¼‰
    rule_name = file_path.stem
    # è¾“å‡ºç›®å½•ï¼šoutput/è§„åˆ™åç§°/
    rule_out_dir = OUTPUT_ROOT / rule_name
    rule_out_dir.mkdir(exist_ok=True)
    print(f"\nğŸ“„ å¤„ç†è§„åˆ™: {rule_name} (åŸŸåæ•°: {len(domains)})")

    # ç”Ÿæˆæ‰€æœ‰å¿…è¦æ ¼å¼ï¼ˆå–æ¶ˆå†—ä½™æ ¼å¼ï¼‰
    for fmt_name, fmt in FORMAT_CONFIG.items():
        # ç”Ÿæˆè§„åˆ™å†…å®¹
        rules = fmt["convert"](domains)
        # è®¡ç®—æœ‰æ•ˆè§„åˆ™æ•°
        total = len(rules["rules"][0]["domain_suffix"]) if fmt_name == "singbox" else len(rules)
        # è¾“å‡ºæ–‡ä»¶è·¯å¾„ï¼šoutput/è§„åˆ™åç§°/[æ ¼å¼å].[åç¼€]
        output_file = rule_out_dir / f"{fmt_name}{fmt['suffix']}"

        # æ„å»ºå¤´éƒ¨æ³¨é‡Š
        comment = fmt["comment"]
        header = [
            f"{comment}{fmt['title']}",
            f"{comment}æè¿°ï¼š{fmt['desc']}",
            f"{comment}ç‰ˆæœ¬ï¼š{meta['version']}",
            f"{comment}æ›´æ–°æ—¶é—´ï¼š{meta['time']}",
            f"{comment}è§„åˆ™æ•°é‡ï¼š{total}",
            f"{comment}æ¥æºï¼š{meta['repo']}",
            f"{comment}"
        ]

        # å†™å…¥æ–‡ä»¶ï¼ˆå–æ¶ˆå†—ä½™å†™å…¥é€»è¾‘ï¼‰
        try:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write('\n'.join(header))
                if fmt_name == "singbox":
                    json.dump(rules, f, indent=2, ensure_ascii=False)
                else:
                    f.write('\n'.join(rules))
            print(f"âœ… ç”Ÿæˆ: {output_file.relative_to(BASE_DIR)}")
        except Exception as e:
            print(f"âŒ ç”Ÿæˆ{fmt_name}å¤±è´¥: {e}")


def main():
    meta = get_meta()
    # æ£€æŸ¥è¾“å…¥ç›®å½•
    if not DOMAIN_DIR.exists():
        print(f"âŒ é”™è¯¯ï¼šè¾“å…¥ç›®å½•ä¸å­˜åœ¨ - {DOMAIN_DIR}")
        return

    # ä»…å¤„ç†domainç›®å½•ä¸‹çš„.txtæ–‡ä»¶ï¼ˆå–æ¶ˆå…¶ä»–æ–‡ä»¶å¤„ç†ï¼‰
    for file in DOMAIN_DIR.glob("*.txt"):
        if file.is_file():
            process_file(file, meta)
    
    print(f"\nğŸ‰ æ‰€æœ‰è§„åˆ™ç”Ÿæˆå®Œæˆï¼Œè¾“å‡ºç›®å½•: {OUTPUT_ROOT.relative_to(BASE_DIR)}")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nâš ï¸ ç”¨æˆ·ä¸­æ–­æ“ä½œ")
